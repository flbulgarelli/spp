options {
   STATIC = false ;
}
PARSER_BEGIN(PredicateParser)
package pparser;
import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.List;
import java.math.BigDecimal;

/**
 * A predicate-like syntax predicates parse
 * @author flbulgarelli
 */
public class PredicateParser {
  private EventHandler handler;
  private ValuesFactory factory;
  
  public void setEventHandler(EventHandler handler) {
    this.handler = handler;
  }

  /***
   * Parses the given expression, using a ValuesFactory for creating the values parsed, and
   * and EventHandler, for observing the predicates detection events the parses produces.
   * @throws IllegalArgumentException when the expression is not valid 
   */
  public static void parse(String expression, ValuesFactory factory, EventHandler handler) {
    try {
      PredicateParser parser = new PredicateParser(new ByteArrayInputStream(expression.getBytes()));
      parser.handler = handler;
      parser.factory = factory;
      parser.doParse();
    } catch (ParseException e) {
      throw new IllegalArgumentException("Syntax error in predicate expression " + expression + ". Cause: "
        + e.getMessage());
    }
  }
  
  /**
   * Validates this expression is parseable.
   *  
   *  It fails with and exception if not possible. Otherwise, does nothing.  
   */
  public static void tryParse(String expression) {
    parse(expression, new NullValuesFactory(), new NullEventHandler());
  }
  
}
PARSER_END(PredicateParser)


SKIP : { " " | "\n" | "\r" | "\t" }

TOKEN : { < COMMA : "," > }
TOKEN : { < AND : "and" > }
TOKEN : { < OR : "or" > }

TOKEN : { < DOT : "." > }

TOKEN : { < OPEN_PAR : "(" > }
TOKEN : { < CLOSE_PAR : ")" > }
TOKEN : { < OPEN_BRACKET : "[" > }
TOKEN : { < CLOSE_BRACKET : "]" > }

TOKEN : { < IDENTIFIER : ["a"-"z","A"-"Z", "_"](["a"-"z","A"-"Z","0"-"9"])* > }

TOKEN : { < NUMBER :  (["0"-"9",".", "+", "-"])+ > }
TOKEN : { < STRING :  "\"" (~["\""])* "\"" > }

TOKEN : { < EQ : "=" >  }
TOKEN : { < GT : ">" >  }
TOKEN : { < LT : "<" >  }
TOKEN : { < GTE : ">=" >  }
TOKEN : { < LTE : "<=" >  }
TOKEN : { < NEQ : "<>" | "!=" | "/=" | "\\=" >  }

Operator operator() :
{ Operator operator; }
{
  (  < EQ > { operator = Operator.EQ; }
  | < GT > { operator = Operator.GT; }
  | < LT > { operator = Operator.LT; } 
  | < LTE > { operator = Operator.LTE; } 
  | < GTE > { operator = Operator.GTE; } 
  | < NEQ > { operator = Operator.NEQ; })
   { return operator; }
}

void doParse() : 
{ }
{ 
   predicateLevel1() 
}

void predicateLevel1() :
{ }
{
   predicateLevel2() ( < OR > predicateLevel2() { handler.orPredicate(); } )* 
}

void predicateLevel2() :
{}
{
   predicateLevel3() ( < AND > predicateLevel3() { handler.andPredicate(); } )*
}

void predicateLevel3() :
{}
{ 
  LOOKAHEAD(< IDENTIFIER > < OPEN_PAR >)
  keywordPredicate()  |
  LOOKAHEAD(< IDENTIFIER > ( < DOT > < IDENTIFIER > )* (< EQ > | < NEQ > | < GT > | < LT > | < GTE > | < LTE >) ) 
  operatorPredicate() | 
  idPredicate() |
  < OPEN_PAR > predicateLevel1() < CLOSE_PAR > 
}

void idPredicate() :
{
  Object arg0;
}
{
  arg0 = path()
  { 
      handler.idPredicate(arg0);
  }
}


void keywordPredicate() :
{
  Token operation; 
  Object arg0, arg1 = null, arg2 = null;
}
{
  operation = < IDENTIFIER >
  < OPEN_PAR >
  arg0 = expression()
  (< COMMA >
  arg1 = expression()
  (< COMMA >
  arg2 = expression())?)?
  < CLOSE_PAR > 
  { 
      handler.keywordPredicate(operation.image, arg0, arg1, arg2);
  }
}

void operatorPredicate() :
{
  Operator operator; 
  Object arg0, arg1;
}
{
  arg0 = expression()
  (operator = operator() ) 
  arg1 = expression()
  { 
      handler.operatorPredicate(operator, arg0, arg1);
  }
}

Object path() :
{ 
  List<String> routes = new ArrayList<String>();
  Token route = null; 
}
{
  route = < IDENTIFIER >
  {  routes.add(route.image); }
  (< DOT >
  route = < IDENTIFIER > 
  { routes.add(route.image); })*
  
  { return factory.createPath(routes); }
}


Object expression() :
{ Object o = null; }
{
  (o = stringValue() |
   o = numericValue() |
   o = listValue() |
   o = path() )
  { return o; }   
}

Object stringValue() :
{ Token v; }
{
  v =  <STRING>
  { return factory.createString(v.image); }
}

Object numericValue() :
{ Token v; }
{
  v =  <NUMBER>
  { return factory.createNumber(v.image); }
}


List<Object> listValue() :
{ List list = new ArrayList(); 
  Object element = null; 
}
{	
	<OPEN_BRACKET>
	(element = expression()
	{ list.add(element); } 
	( < AND > element = expression() 
	  { list.add(element); }
	)*)?	
	<CLOSE_BRACKET>
	{ return list; }
}

